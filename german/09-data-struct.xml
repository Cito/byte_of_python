<chapter id="data-structures">

	<!-- German translation 2005-02-27 by Lutz Horn -->
	<!-- German translation 2005-11-14 by Christoph Zwerschke -->
	<!-- Proofreading 2005-11-15 Christoph Zwerschke -->
	<!-- Proofreading 2006-08-04 Gunter Hannig -->

	<title>Datenstrukturen <!--Data Structures--></title>

	<section id="data-structures-intro">
		<title>Einführung <!--Introduction--></title>

		<para>

		Datenstrukturen sind im Wesentlichen einfach das - <emphasis>Strukturen</emphasis>,
		die einige <emphasis>Daten</emphasis> zusammenhalten können. Mit anderen Worten werden
		sie benutzt, um eine Ansammlung von verwandten Daten zu speichern.

		<!-- Data structures are basically just that - they are <emphasis>structures</emphasis> which
		can hold some <emphasis>data</emphasis> together. In other words, they are used to store
		a collection of related data. -->

		</para>
		<para>

		In Python  gibt es drei eingebaute Datenstrukturen - Listen, Tupel und
		Dictionaries (Wörterbücher). Wir werden sehen, wie sich jede dieser drei
		Datenstrukturen verwenden lässt und wie sie unser Leben vereinfachen.

		<!-- There are three built-in data structures in Python - list, tuple and dictionary. We will
		see how to use each of them and how they make life easier. -->

		</para>
	</section>

	<section id="list">
		<title>Listen</title>  <!-- List -->

		<para>

		Eine <literal>Liste</literal> ist eine Datenstruktur, die eine angeordnete
		Sammlung von Objekten enthält, d.h. in einer Liste kann man eine
		<emphasis>Sequenz</emphasis> (eine Abfolge) von Objekten abspeichern.
		Sie können sich das wie eine Einkaufsliste vorstellen, die eine Liste
		von zu kaufenden Dingen darstellt, außer dass Sie auf ihrer Einkaufsliste
		die Dinge wahrscheinlich in getrennten Zeilen stehen haben,
		wohingegen in Python zwischen den Objekten Kommas gesetzt werden müssen.

		<!-- A <literal>list</literal> is a data structure that holds an ordered collection of items
		i.e. you can store a <emphasis>sequence</emphasis> of items in a list. This is easy to
		imagine if you can think of a shopping list where you have a list of items to buy,
		except that you probbly have each item on a separate line in your shopping list whereas
		in Python you put commas in between them. -->

		</para>
		<para>

		Eine Liste von Objekten muss durch eckige Klammern (<literal>[</literal>
		und <literal>]</literal>) eingeschlossen sein, damit Python sie als Liste erkennt.
		Sobald Sie eine Liste erzeugt haben, können Sie ihr Objekte hinzufügen,
		welche aus ihr entfernen oder nach bestimmten Objekten in ihr suchen. Da wir
		Objekte hinzufügen und entfernen können, nennen wir eine Liste einen
		<emphasis>veränderlichen</emphasis> Datentyp.

		<!-- The list of items should be enclosed in square brackets so that Python understands that
		you are specifying a list. Once you have created a list, you can add, remove or search
		for items in the list. Since, we can add and remove items, we say that a list is a
		<emphasis>mutable</emphasis> data type i.e. this type can be altered. -->

		</para>

		<section id="list-objects-classes">
			<title>Kurzeinführung in Objekte und Klassen</title> <!-- Quick
			introduction to Objects and Classes-->

			<para>

			Bisher habe ich zwar die Diskussion von Objekten und Klassen
			prinzipiell aufgeschoben, doch brauchen wir jetzt eine kurze Erläuterung
			dieser Konzepte, damit Sie Listen besser verstehen können. Wir werden
			dieses Thema noch detaillierter in einem eigenen
			<link linkend="oops">Kapitel</link> untersuchen.

			<!-- Although, I've been generally delaying the discussion of objects and classes
			till now, a little explanation is needed right now so that you can understand
			lists better. We will still explore this topic in detail in its own
			<link linkend="oops">chapter</link>. -->

			</para>
			<para>

			Eine Liste ist ein Beispiel für die Verwendung von Objekten und Klassen.
			Wenn Sie eine Variable <varname>i</varname> verwenden und ihr einen Wert,
			z.B. die Ganzzahl <literal>5</literal> zuweisen, können Sie sich das als
			die Erzeugung eines <emphasis role="bold">Objekts</emphasis> (einer
			Instanz) <varname>i</varname> der <emphasis role="bold">Klasse</emphasis>
			(des Typs) <classname>int</classname> vorstellen. Sie können sich auch
			den Hilfetext <literal>help(int)</literal> anzeigen lassen, um dies besser
			zu verstehen.

			<!-- A list is an example of usage of objects and classes. When you use a variable
			<varname>i</varname> and assign a value to it, say integer <literal>5</literal>
			to it, you can think of it as creating an <emphasis role="bold">object</emphasis>
			(instance) <varname>i</varname> of <emphasis role="bold">class</emphasis> (type)
			<classname>int</classname>. In fact, you can see <literal>help(int)</literal>
			to understand this better. -->

			</para>
			<para>

			Eine Klasse kann <emphasis role="bold">Methoden</emphasis> haben, d.h.
			Funktionen, die zur Verwendung im Zusammenhang mit genau dieser Klasse
			definiert werden. Sie können diese Funktionen einer Klasse nur verwenden,
			wenn Sie ein Objekt der Klasse haben. Zum Beispiel stellt Python die Methode
			<function>append</function> der Klasse <classname>list</classname> zur
			Verfügung. Diese Methode erlaubt es Ihnen, ein Objekt am Ende einer
			Liste anzufügen. So wird zum Beispiel <literal>meineliste.append("ein Ding")</literal>
			den String <literal>"ein Ding"</literal> am Ende der Liste
			<varname>meineliste</varname> anfügen. Beachten Sie die Verwendung der
			Punktnotation, mit der Sie die Methode eines Objekts aufrufen können.

			<!-- A class can also have <emphasis role="bold">methods</emphasis> i.e. functions
			defined for use with respect to that class only. You can use these pieces of
			functionality only when you have an object of that class. For example, Python
			provides an <function>append</function> method for the <classname>list</classname>
			class which allows you to add an item to the end of the list. For example,
			<literal>mylist.append('an item')</literal> will add that string to the list
			<varname>mylist</varname>. Note the use of dotted notation for accessing methods
			of the objects. -->

			</para>
			<para>

			Außerdem kann eine Klasse <emphasis role="bold">Felder</emphasis> haben,
			bei denen es sich um nichts weiter als Variablen handelt, die nur im Zusammenhang
			mit der Klasse verwendet werden können. Sie können diese Variablen/Namen nur
			verwenden, wenn Sie ein Objekt der Klasse haben. Auf Felder wird ebenfalls
			mit der Punktnotation zugegriffen, z.B. <varname>meineliste.feld</varname>.

			<!-- A class can also have <emphasis role="bold">fields</emphasis> which are nothing
			but variables defined for use with respect to that class only. You can use these
			variables/names only when you have an object of that class. Fields are also
			accessed by the dotted notation, for example, <varname>mylist.field</varname>. -->

			</para>
		</section>

		<section id="using-lists">
			<title>Benutzung von Listen</title> <!-- Using Lists -->

			<example id="using-lists-example">
				<title>Benutzung von Listen <!-- Using lists -->
					(<ulink url="code/listen.py">listen.py</ulink>)
				</title>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

# Dies ist meine Einkaufsliste
einkaufsliste = ['Aepfel', 'Mangos', 'Karotten', 'Bananen']

print 'Ich habe', len(einkaufsliste), 'Dinge einzukaufen.'

print 'Diese Dinge sind:', # Beachten Sie das Komma am Zeilenende
for ding in einkaufsliste:
	print ding,

print '\nIch muss auch Reis einkaufen.'
einkaufsliste.append('Reis')
print 'Meine Einkaufsliste ist jetzt:'
print einkaufsliste

print 'Jetzt werde ich meine Einkaufsliste sortieren.'
einkaufsliste.sort()
print 'Die sortierte Einkaufsliste ist:'
print einkaufsliste

print 'Zuerst werde ich', einkaufsliste[0], 'kaufen.'
altesding = einkaufsliste[0]
del einkaufsliste[0]
print 'Ich habe', altesding, 'gekauft.'
print 'Meine Einkaufsliste ist jetzt:'
print einkaufsliste
				]]>
				</programlisting>
				<!-- <![CDATA[
#!/usr/bin/python

# This is my shopping list
shoplist = ['apple', 'mango', 'carrot', 'banana']

print 'I have', len(shoplist), 'items to purchase.'

print 'These items are:', # Notice the comma at end of the line
for item in shoplist:
	print item,

print '\nI also have to buy rice.'
shoplist.append('rice')
print 'My shopping list is now', shoplist

print 'I will sort my list now'
shoplist.sort()
print 'Sorted shopping list is', shoplist

print 'The first item I will buy is', shoplist[0]
olditem = shoplist[0]
del shoplist[0]
print 'I bought the', olditem
print 'My shopping list is now', shoplist
				]]> -->
			</example>

			<section id="using-lists-output">
				<title>Ausgabe</title> <!-- Output -->

				<screen>
				<![CDATA[
$ python listen.py
Ich habe 4 Dinge einzukaufen.
Diese Dinge sind: Aepfel Mangos Karotten Bananen
Ich muss auch Reis einkaufen.
Meine Einkaufsliste ist jetzt:
['Aepfel', 'Mangos', 'Karotten', 'Bananen', 'Reis']
Jetzt werde ich meine Einkaufsliste sortieren.
Die sortierte Einkaufsliste ist:
['Aepfel', 'Bananen', 'Karotten', 'Mangos', 'Reis']
Zuerst werde ich Aepfel kaufen.
Ich habe Aepfel gekauft.
Meine Einkaufsliste ist jetzt:
['Bananen', 'Karotten', 'Mangos', 'Reis']
				]]>
				</screen>
				<!-- <![CDATA[
$ python using_list.py
I have 4 items to purchase.
These items are: apple mango carrot banana
I also have to buy rice.
My shopping list is now ['apple', 'mango', 'carrot', 'banana', 'rice']
I will sort my list now
Sorted shopping list is ['apple', 'banana', 'carrot', 'mango', 'rice']
The first item I will buy is apple
I bought the apple
My shopping list is now ['banana', 'carrot', 'mango', 'rice']
				]]> -->
			</section>

			<section id="using-lists-how">
				<title>So funktioniert es</title> <!-- How It Works -->

				<para>

				Die Variable <varname>einkaufsliste</varname> ist eine Einkaufsliste für
				jemanden, der auf den Markt geht. In <varname>einkaufsliste</varname>
				speichern wir nur die Namen der Dinge als Strings ab; aber denken Sie daran,
				dass Sie einer Liste <emphasis>alle Arten von Objekten</emphasis> hinzufügen
				können, also auch Zahlen und sogar andere Listen.

				<!-- The variable <varname>shoplist</varname> is a shopping list for someone
				who is going to the market. In <varname>shoplist</varname>, we only store
				strings of the names of the items to buy but remember you can add
				<emphasis>any kind of object</emphasis> to a list including numbers and
				even other lists. -->

				</para>
				<para>

				Wir haben auch die <literal>for..in</literal>-Schleife verwendet, um
				die Elemente in der Liste zu durchlaufen. Inzwischen werden Sie gemerkt
				haben, dass eine Liste auch eine Sequenz ist. Die Besonderheiten von
				Sequenzen werden wir in einem späteren
				<link linkend="sequences">Abschnitt</link> besprechen.

				<!-- We have also used the <literal>for..in</literal> loop to iterate through
				the items of the list. By now, you must have realised that a list is
				also a sequence. The speciality of sequences will be discussed in a later
				<link linkend="sequences">section</link> -->

				</para>
				<para>

				Beachten Sie, dass wir ein <emphasis>Komma</emphasis> am Ende der
				<literal>print</literal>-Anweisung verwendet haben, um die automatische
				Ausgabe eines Zeilenumbruchs nach der <literal>print</literal>-Anweisung
				zu unterdrücken. Das ist eine etwas unschöne Weise, dies zu erreichen,
				aber sie ist einfach und erreicht genau das, was wir wollen.

				<!-- Notice that we use a <emphasis>comma</emphasis> at the end of the
				<literal>print</literal> statement to suppress the automatic printing of
				a line break after every <literal>print</literal> statement. This is a bit
				of an ugly way of doing it, but it is simple and gets the job done. -->

				</para>
				<para>

				Als Nächstes fügen wir unter Benutzung der Methode
				<methodname>append</methodname> der Liste ein Objekt hinzu, wie
				wir es bereits besprochen haben. Dann überprüfen wir, ob das
				Objekt der Liste wirklich hinzugefügt wurde, indem wir den Inhalt
				der Liste einfach der <literal>print</literal>-Anweisung übergeben,
				die uns die Liste in einer übersichtlichen Weise ausgibt.

				<!-- Next, we add an item to the list using the <methodname>append</methodname>
				method of the list object, as already discussed before. Then, we check that
				the item has been indeed added to the list by printing the contents of the
				list by simply passing the list to the <literal>print</literal> statement
				which prints it in a neat manner for us. -->

				</para>
				<para>

				Danach sortieren wir die Liste mit der zur Liste gehörenden Methode
				<methodname>sort</methodname>. Beachten Sie, dass diese Methode
				die Liste selbst verändert und nicht etwa eine veränderte Liste
				zurückliefert - hierin unterscheidet sie sich im Verhalten von Strings.
				Das ist gemeint, wenn wir sagen, eine Liste sei
				<emphasis>veränderlich</emphasis>, Strings dagegen
				<emphasis>unveränderlich</emphasis>.

				<!-- Then, we sort the list by using the <methodname>sort</methodname> method
				of the list. Understand that this method affects the list itself and does
				not return a modified list - this is different from the way strings
				work. This is what we mean by saying that lists are <emphasis>mutable</emphasis>
				and that strings are <emphasis>immutable</emphasis>. -->

				</para>
				<para>

				Nachdem wir etwas auf dem Markt gekauft haben, wollen wir es aus der
				Liste entfernen. Das erreichen wir durch die Anweisung <literal>del</literal>.
				Wir geben hierbei an, welches Objekt wir aus der Liste entfernen wollen, und
				die <literal>del</literal>-Anweisung löscht es für uns aus der Liste.
				Da wir das erste Objekt aus der Liste entfernen wollen, verwenden wir
				<literal>del einkaufsliste[0]</literal> (erinnern Sie sich daran, dass
				Python bei 0 zu zählen beginnt).

				<!-- Next, when we finish buying an item in the market, we want to remove it
				from the list. We achieve this by using the <literal>del</literal>
				statement. Here, we mention which item of the list we want to remove and
				the <literal>del</literal> statement removes it fromt he list for us.
				We specify that we want to remove the first item from the list and hence
				we use <literal>del shoplist[0]</literal> (remember that Python starts
				counting from 0). -->

				</para>
				<para>

				Wenn Sie alle Methoden wissen möchten, die für Listen-Objekte
				definiert sind, dann erhalten Sie die Details mit <literal>help(list)</literal>.

				<!-- If you want to know all the methods defined by the list object, see
				<literal>help(list)</literal> for complete details. -->

				</para>
			</section>
		</section>
	</section>

	<section id="tuple">
		<title>Tupel</title> <!-- Tuple -->

		<para>

		Tupel sind genau wie Listen, außer dass sie <emphasis role="bold">unveränderlich</emphasis>
		wie Strings sind, d.h. man kann Tupel nicht abändern. Tupel werden definiert, indem man
		durch Komma getrennte Objekte innerhalb eines normalen Klammerpaars angibt. Tupel werden
		normalerweise immer dann gebraucht, wenn eine Anweisung oder eine benutzerdefinierte Funktion
		mit Sicherheit davon ausgehen kann, dass die verwendete Sammlung von Werten, d.h. das Wertetupel,
		sich nicht verändern wird.

		<!-- Tuples are just like lists except that they are <emphasis role="bold">immutable</emphasis>
		like strings i.e. you cannot modify tuples. Tuples are defined by specifying items
		separated by commas within a pair of parentheses. Tuples are usually used in cases where
		a statement or a user-defined function can safely assume that the collection of values
		i.e. the tuple of values used will not change. -->

		</para>

		<section id="using-tuples">
			<title>Benutzung von Tupeln</title> <!-- Using Tuples -->

			<example id="using-tuples-example">
				<title>Benutzung von Tupeln <!-- Using tuples -->
					(<ulink url="code/tupel.py">tupel.py</ulink>)
				</title>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

zoo = ('Wolf', 'Elefant', 'Pinguin')
print 'Die Zahl der Tiere im Zoo ist', len(zoo)

neuer_zoo = ('Affe', 'Delfin', zoo)
print 'Die Zahl der Tiere im neuen Zoo ist', len(neuer_zoo)
print 'Alle Tiere im neuen Zoo sind', neuer_zoo
print 'Die aus dem alten Zoo uebernommenen Tiere sind', neuer_zoo[2]
print 'Das letzte aus dem alten Zoo uebernommene Tier ist ein', neuer_zoo[2][2]
				]]>
				</programlisting>
				<!-- <![CDATA[
#!/usr/bin/python

zoo = ('wolf', 'elephant', 'penguin')
print 'Number of animals in the zoo is', len(zoo)

new_zoo = ('monkey', 'dolphin', zoo)
print 'Number of animals in the new zoo is', len(new_zoo)
print 'All animals in new zoo are', new_zoo
print 'Animals brought from old zoo are', new_zoo[2]
print 'Last animal brought from old zoo is', new_zoo[2][2]
				]]> -->
			</example>

			<section id="using-tuples-output">
				<title>Ausgabe</title> <!-- Output -->

				<screen>
				<![CDATA[
$ python tupel.py
Die Zahl der Tiere im Zoo ist 3
Die Zahl der Tiere im neuen Zoo ist 3
Alle Tiere im neuen Zoo sind ('Affe', 'Delfin', ('Wolf', 'Elefant', 'Pinguin'))
Die aus dem alten Zoo uebernommenen Tiere sind ('Wolf', 'Elefant', 'Pinguin')
Das letzte aus dem alten Zoo uebernommene Tier ist ein Pinguin
				]]>
				</screen>
				<!-- <![CDATA[
$ python using_tuple.py
Number of animals in the zoo is 3
Number of animals in the new zoo is 3
All animals in new zoo are ('monkey', 'dolphin', ('wolf', 'elephant', 'penguin'))
Animals brought from old zoo are ('wolf', 'elephant', 'penguin')
Last animal brought from old zoo is penguin
				]]> -->
			</section>

			<section id="using-tuples-how">
				<title>So funktioniert es</title> <!-- How It Works -->

				<para>

				Die Variable <varname>zoo</varname> bezeichnet ein Tupel von Objekten.
				Wir erkennen, dass die Funktion <function>len</function> eingesetzt
				werden kann, um die Länge des Tupels zu ermitteln. Dies zeigt außerdem,
				dass auch ein Tupel eine <link linkend="sequences">Sequenz</link> ist.

				<!-- The variable <varname>zoo</varname> refers to a tuple of items. We see
				that the <function>len</function> function can be used to get the length
				of the tuple. This also indicates that a tuple is a
				<link linkend="sequences">sequence</link> as well. -->

				</para>
				<para>

				Wir transferieren diese Tiere nun in einen neuen Zoo, weil der alte Zoo
				geschlossen wird. Daher erhält das Tupel <varname>neuer_zoo</varname>
				einige Tiere, die bereits dort vorhanden sind, zusammen mit den Tieren,
				die vom alten Zoo übernommen worden sind. Um zur Realität zurückzukehren,
				beachten Sie, dass ein Tupel innerhalb eines Tupels nicht seine Identität
				verliert.

				<!-- We are now shifting these animals to a new zoo since the old zoo is being
				closed. Therefore, the <varname>new_zoo</varname> tuple contains some
				animals which are already there along with the animals brought over from
				the old zoo. Back to reality, note that a tuple within a tuple does not
				lose its identity. -->

				</para>
				<para>

				Wir können auf die Objekte in einem Tupel zugreifen, indem wir die Position
				des Objekts innerhalb eines Paars eckiger Klammern angeben, genau wie wir
				es bei den Listen getan haben. Dies wird der <emphasis>Indizierungsoperator</emphasis>
				genannt. Wir greifen auf das dritte Objekt in <varname>neuer_zoo</varname>
				mittels <literal>neuer_zoo[2]</literal> zu. Dies ist ziemlich einfach,
				wenn man einmal die Schreibweise verstanden hat.

				<!-- We can access the items in the tuple by specifying the item's position
				within a pair of square brackets just like we did for lists. This is
				called the <emphasis>indexing</emphasis> operator. We access the third
				item in <varname>new_zoo</varname> by specifying
				<literal>new_zoo[2]</literal> and we access the third item in the third
				item in the <varname>new_zoo</varname> tuple by specifying
				<literal>new_zoo[2][2]</literal>. This is pretty simple once you've
				understood the idiom. -->

				</para>

				<formalpara>
					<title>Tupel mit keinem oder nur einem Objekt</title> <!-- Tuple with 0 or 1 items -->

					<para>

					Ein leeres Tupel wird durch ein leeres Klammerpaar gebildet,
					etwa <literal>meinleerestupel = ()</literal>. Ein Tupel mit
					nur einem einzigen Objekt ist jedoch nicht so einfach. Sie müssen
					es durch ein auf das erste (und einzige) Objekt folgendes Komma
					kennzeichnen, damit Python zwischen einem Tupel und einem Klammerpaar
					unterscheiden kann, das einfach nur ein Objekt in einem Ausdruck umschließt,
					d.h. Sie müssen <literal>einzelnesetwas = (2 , )</literal> schreiben,
					wenn Sie ein Tupel meinen, das nur die Zahl <literal>2</literal> enthält.

					<!-- An empty tuple is constructed by an empty pair of parentheses
					such as <literal>myempty = ()</literal>. However, a tuple with
					a single item is not so simple. You have to specify it using a
					comma following the first (and only) item so that Python can
					differentiate between a tuple and a pair of parentheses surrounding
					the object in an expression i.e. you have to specify
					<literal>singleton = (2 , )</literal> if you mean you want a tuple
					containing the item <literal>2</literal>. -->

					</para>
				</formalpara>

				<note>
					<title>Anmerkung für Perl-Programmierer</title> <!-- Note for Perl programmers -->

					<para>

					Eine Liste innerhalb einer Liste verliert nicht ihre Identität,
					d.h. Listen werden nicht automatisch &quot;plattgebügelt&quot; wie in Perl.
					Das Gleiche gilt für ein Tupel innerhalb eines Tupels, oder ein
					Tupel innerhalb einer Liste, oder eine Liste innerhalb eine Tupels usw.
					Soweit es Python betrifft, sind dies nur Objekte, die mittels eines
					anderen Objekts gespeichert werden, das ist alles.

					<!-- A list within a list does not lose its identity i.e. lists are not
					flattened as in Perl. The same applies to a tuple within a tuple,
					or a tuple within a list, or a list within a tuple, etc. As far as
					Python is concerned, they are just objects stored using another
					object, that's all. -->

					</para>
				</note>
			</section>
		</section>
		<section id="tuple-print">
			<title>Tupel und die print-Anweisung</title> <!-- Tuples and the print statement -->

			<para>

			Eine der häufigsten Anwendungen von Tupeln ist bei der print-Anweisung.
			Hier ist ein Beispiel:

			<!-- One of the most common usage of tuples is with the print statement. Here is an
			example: -->

			</para>

			<example id="tuple-print-example">
				<title>Ausgabe mittels Tupeln <!-- Output using tuples -->
					(<ulink url="code/print_tupel.py">print_tupel.py</ulink>)
				</title>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

alter = 22
name = 'Swaroop'

print '%s ist %d Jahre alt.' % (name, alter)
print 'Warum spielt %s mit diesem Python?' % name
				]]>
				</programlisting>
				<!-- <![CDATA[
#!/usr/bin/python

age = 22
name = 'Swaroop'

print '%s is %d years old' % (name, age)
print 'Why is %s playing with that python?' % name
				]]> -->
			</example>

			<section id="tuple-print-output">
				<title>Ausgabe</title> <!-- Output -->
				<screen>
				<![CDATA[
$ python print_tuple.py
Swaroop ist 22 Jahre alt.
Warum spielt Swaroop mit diesem Python?
				]]>
				</screen>
				<!-- <![CDATA[
$ python print_tuple.py
Swaroop is 22 years old
Why is Swaroop playing with that python?
				]]> -->
			</section>

			<section id="tuple-print-how">
				<title>So funktioniert es</title> <!-- How It Works -->

				<para>

				Der <literal>print</literal>-Anweisung kann man einen String mit speziellen
				Angaben übergeben, der von einem <literal>%</literal>-Zeichen und einem Tupel
				von Objekten gefolgt wird, die auf die Angaben in dem String passen.
				Diese Angaben werden dazu benutzt, die Ausgabe in einer bestimmten Weise
				zu formatieren. Sie können zum Beispiel aus einem <literal>%s</literal>
				für Strings und <literal>%d</literal> für Ganzzahlen bestehen. Das Tupel
				muss Objekte haben, die diesen Angaben in der gleichen Reihenfolge entsprechen.

				<!-- The <literal>print</literal> statement can take a string using certain
				specifications followed by the <literal>%</literal> symbol followed by
				a tuple of items matching the specification. The specifications are used
				to format the output in a certain way. The specification can be like
				<literal>%s</literal> for strings and <literal>%d</literal> for integers.
				The tuple must have items corresponding to these specifications in the same
				order. -->

				</para>
				<para>

				Beachten Sie die erste Anwendung, wo wir zuerst <literal>%s</literal>
				benutzen, was der Variablen <varname>name</varname> entspricht, die das
				erste Objekt in dem Tupel ist, und als zweite Angabe <literal>%d</literal>,
				was <varname>alter</varname> entspricht, dem zweiten Objekt im Tupel.

				<!-- Observe the first usage where we use <literal>%s</literal> first and this
				corresponds to the variable <varname>name</varname> which is the first
				item in the tuple and the second specification is <literal>%d</literal>
				corresponding to <varname>age</varname> which is the second item in the
				tuple. -->

				</para>
				<para>

				Python wandelt hier jedes Objekt des Tupels in einen String um
				und setzt diese anstelle der Formatierungsangaben. Daher wird
				<literal>%s</literal> durch den Wert der Variablen <varname>name</varname>
				ersetzt und so weiter.

				<!-- What Python does here is that it converts each item in the tuple into a
				string and substitutes that string value into the place of the
				specification. Therefore the <literal>%s</literal> is replaced by the
				value of the variable <varname>name</varname> and so on. -->

				</para>
				<para>

				Dieser Gebrauch der <literal>print</literal>-Anweisung macht es äußerst
				einfach, Ausgaben auf den Bildschirm zu schreiben, und vermeidet eine
				Menge von String-Manipulationen, mit denen man das Gleiche erreichen könnte.
				Man kann so auch vermeiden, Kommas zu benutzen, wie wir es bisher
				gemacht haben.

				<!-- This usage of the <literal>print</literal> statement makes writing
				output extremely easy and avoids lot of string manipulation to achieve
				the same. It also avoids using commas everywhere as we have done till now. -->

				</para>
				<para>

				Meistens kann man die Angabe <literal>%s</literal> verwenden, und sich
				Python um den Rest kümmern lassen. Das funktioniert sogar für Zahlen.
				Sie können aber auch die korrekten Angaben machen, um damit eine weitere
				Überprüfung auf Korrektheit in Ihr Programm einzubauen.

				<!-- Most of the time, you can just use the <literal>%s</literal> specification
				and let Python take care of the rest for you. This works even for numbers.
				However, you may want to give the correct specifications since this adds
				one level of checking that your program is correct. -->

				</para>
				<para>

				In der zweiten <literal>print</literal>-Anweisung benutzen wir eine
				einzelne Formatierungsangabe, die von einem <literal>%</literal>-Zeichen
				und einem einzelnen Objekt gefolgt wird - hier gibt es kein Klammerpaar.
				Dies funktioniert aber nur in dem Fall, dass nur eine einzelne
				Formatierungsangabe im String vorhanden ist.

				<!-- In the second <literal>print</literal> statement, we are using a single
				specification followed by the <literal>%</literal> symbol followed by a
				single item - there are no pair of parentheses. This works only in the case
				where there is a single specification in the string. -->

				</para>
			</section>
		</section>
	</section>

	<section id="dictionary">
		<title>Dictionaries</title> <!-- Dictionary -->

		<para>

		Ein Dictionary (Wörterbuch) ist wie ein Adressbuch, in dem man die Adressen oder
		Kontaktangaben zu einer Person finden kann, wenn man ihren Namen kennt, d.h. wir
		ordnen <emphasis role="bold">Schlüssel</emphasis> (Namen) <emphasis role="bold">Werte</emphasis>
		(Kontaktdaten) zu. Beachten Sie, dass der Schlüssel eindeutig sein muss, genau wie
		man auch nicht die korrekte Information herausfinden kann, wenn man zwei Personen
		des exakt gleichen Namens in seinem Adressbuch hat.

		<!-- A dictionary is like an address-book where you can find the address or contact details
		of a person by knowing only his/her name i.e. we associate
		<emphasis role="bold">keys</emphasis> (name) with <emphasis role="bold">values</emphasis>
		(details). Note that the key must be unique just like you cannot find out the correct
		information if you have two persons with the exact same name. -->

		</para>
		<para>

		Beachten Sie, dass man nur unveränderliche Objekte (wie Strings) als Schlüssel eines
		Dictionaries verwenden kann, aber dass man sowohl unveränderliche als auch veränderliche
		Objekte als Werte des Dictionaries benutzen darf. Das bedeutet im Wesentlichen,
		dass man nur einfache Objekte als Schlüssel verwenden sollte.

		<!-- Note that you can use only immutable objects (like strings) for the keys of a dictionary
		but you can use either immutable or mutable objects for the values of the dictionary.
		This basically translates to say that you should use only simple objects for keys. -->

		</para>
		<para>

		Paare von Schlüsseln und Werten werden in einem Dictionary mittels der Schreibweise
		<literal>d = { schluessel1 : wert1, schluessel2 : wert2 }</literal> angegeben.
		Beachten Sie, dass die Schlüssel/Wert-Paare mit Doppelpunkte getrennt werden
		und die Paare selbst durch Kommas voneinander getrennt werden, und alles insgesamt
		in ein paar geschweifter Klammern eingeschlossen wird.

		<!-- Pairs of keys and valus are specified in a dictionary by using the notation
		<literal>d = {key1 : value1, key2 : value2 }</literal>. Notice that they key/value pairs
		are separated by a colon and the pairs are separated themselves by commas and all this
		is enclosed in a pair of curly brackets. -->

		</para>
		<para>

		Denken Sie daran, dass Schlüssel/Wert-Paare in einem Dictionary in keiner Weise
		sortiert sind. Wenn Sie eine bestimmte Reihenfolge wünschen, dann müssen Sie diese
		vor Gebrauch durch Sortierung der Schlüssel selbst herstellen.

		<!-- Remember that key/value pairs in a dictionary are not ordered in any manner. If you want
		a particular order, then you will have to sort them yourself before using it. -->

		</para>
		<para>

		Die Dictionaries, die Sie benutzen werden, sind Instanzen/Objekte
		der Klasse <classname>dict</classname>.

		<!-- The dictionaries that you will be using are instances/objects of the
		<classname>dict</classname> class. -->

		</para>

		<section id="using-dictionaries">
			<title>Benutzung von Dictionaries</title> <!-- Using Dictionaries -->

			<example id="using-dictionaries-example">
				<title>Benutzung von Dictionaries <!-- Using dictionaries -->
					(<ulink url="code/dict.py">dict.py</ulink>)
				</title>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

# 'ab' steht kurz fuer 'A'dress'b'uch

ab = {		'Swaroop'   : 'swaroopch@byteofpython.info',
		'Larry'     : 'larry@wall.org',
		'Matsumoto' : 'matz@ruby-lang.org',
		'Spammer'   : 'spammer@hotmail.com'
	}

print "Swaroops Adresse ist %s" % ab['Swaroop']

# Ein Schluessel/Wert-Paar hinzufuegen
ab['Guido'] = 'guido@python.org'

# Ein Schluessel/Wert-Paar loeschen
del ab['Spammer']

print '\nEs gibt %d Kontakte im Adressbuch\n' % len(ab)

for name, adresse in ab.items():
	print '%s hat die Adresse %s' % (name, adresse)

if 'Guido' in ab: # oder: ab.has_key('Guido')
	print "\nGuidos Adresse ist %s" % ab['Guido']
				]]>
				</programlisting>
				<!-- <![CDATA[
#!/usr/bin/python

# 'ab' is short for 'a'ddress'b'ook

ab = {		'Swaroop'   : 'swaroopch@byteofpython.info',
		'Larry'     : 'larry@wall.org',
		'Matsumoto' : 'matz@ruby-lang.org',
		'Spammer'   : 'spammer@hotmail.com'
	}

print "Swaroop's address is %s" % ab['Swaroop']

# Adding a key/value pair
ab['Guido'] = 'guido@python.org'

# Deleting a key/value pair
del ab['Spammer']

print '\nThere are %d contacts in the address-book\n' % len(ab)

for name, address in ab.items():
	print 'Contact %s at %s' % (name, address)

if 'Guido' in ab: # OR ab.has_key('Guido')
	print "\nGuido's address is %s" % ab['Guido']
				]]> -->
			</example>

			<section id="using-dictionaries-output">
				<title>Ausgabe</title> <!-- Output -->

				<screen>
				<![CDATA[
$ python dict.py
Swaroops Adresse ist swaroopch@byteofpython.info

Es gibt 4 Kontakte im Adressbuch

Swaroop hat die Adresse swaroopch@byteofpython.info
Matsumoto hat die Adresse matz@ruby-lang.org
Larry hat die Adresse larry@wall.org
Guido hat die Adresse guido@python.org

Guidos Adresse ist guido@python.org
				]]>
				</screen>
				<!-- <![CDATA[
$ python using_dict.py
Swaroop's address is swaroopch@byteofpython.info

There are 4 contacts in the address-book

Contact Swaroop at swaroopch@byteofpython.info
Contact Matsumoto at matz@ruby-lang.org
Contact Larry at larry@wall.org
Contact Guido at guido@python.org

Guido's address is guido@python.org
				]]> -->
			</section>

			<section id="using-dictionaries-how">
				<title>So funktioniert es</title> <!-- How It Works -->

				<para>

				Wir haben unter Benutzung der bereits erläuterten Schreibweise
				ein Dictionary <varname>ab</varname> erzeugt. Wir greifen dann
				auf die Schlüssel/Wert-Paare zu, indem wir den Schlüssel mittels
				des Indizierungsoperators angeben, den wir im Zusammenhang mit
				Listen und Tupeln erörtert haben. Beachten Sie, dass die
				Schreibweise für Dictionaries damit ebenfalls sehr einfach ist.

				<!-- We create the dictionary <varname>ab</varname> using the notation already
				discussed. We then access key/value pairs by specifying the key using the
				indexing operator as discussed in the context of lists and tuples.
				Observe that the syntax is very simple for dictionaries as well. -->

				</para>
				<para>

				Wir können neue Schlüssel/Wert-Paare hinzufügen, indem wir einfach den
				Indizierungsoperator verwenden, um auf einen Schlüssel zuzugreifen und
				den Wert zuzuweisen, so wie wir es für 'Guido' im obigen Fall getan haben.

				<!-- We can add new key/value pairs by simply using the indexing operator to
				access a key and assign that value, as we have done for Guido in the
				above case. -->

				</para>
				<para>

				Wir können Schlüssel/Wert-Paare löschen, indem wir unseren alten Freund
				benutzen - die <literal>del</literal>-Anweisung. Wir geben einfach das
				Dictionary und den Indizierungsoperator für den zu entfernenden Schlüssel
				an und übergeben es an die <literal>del</literal>-Anweisung. Man braucht
				für diese Operation nicht den Wert zu kennen, der diesem Schlüssel entspricht.

				<!-- We can delete key/value pairs using our old friend - the <literal>del</literal>
				statement. We simply specify the dictionary and the indexing operator for the
				key to be removed and pass it to the <literal>del</literal> statement.
				There is no need to know the value corresponding to the key for this
				operation. -->

				</para>
				<para>

				Als Nächstes greifen wir auf alle Schlüssel/Wert-Paare des Dictionaries zu,
				indem wir die <methodname>items</methodname>-Methode des Dictionaries verwenden,
				die eine Liste von Tupeln zurückgibt, bei der jedes Tupel ein Paar von Objekten
				enthält - den Schlüssel, gefolgt von seinem zugehörigen Wert. Wir ermitteln dieses
				Paar und weisen es den Variablen <varname>name</varname> bzw. <varname>adresse</varname>
				zu, und zwar mittels der <literal>for..in</literal>-Schleife für jedes vorhandene
				Schlüssel/Wert-Paar im Dictionary, und geben diese Werte dann im for-Block aus.

				<!-- Next, we access each key/value pair of the dictionary using the
				<methodname>items</methodname> method of the dictionary which returns a
				list of tuples where each tuple contains a pair of items - the key followed
				by the value. We retrieve this pair and assign it to the variables
				<varname>name</varname> and <varname>address</varname> correspondingly
				for each pair using the <literal>for..in</literal> loop and then print
				these values in the for-block. -->

				</para>
				<para>

				Wir können den <literal>in</literal>-Operator oder auch die Methode
				<methodname>has_key</methodname> der Klasse <classname>dict</classname>
				verwenden, um zu überprüfen, ob ein bestimmter Schlüssel im Dictionary
				einen Wert zugeordnet hat. Sie können sich die Dokumentation für die
				vollständige Liste von Methoden der Klasse <classname>dict</classname>
				mittels <literal>help(dict)</literal> anzeigen lassen.

				<!-- We can check if a key/value pair exists using the <literal>in</literal>
				operator or even the <methodname>has_key</methodname> method of the
				<classname>dict</classname> class. You can see the documentation for
				the complete list of methods of the <classname>dict</classname> class
				using <literal>help(dict)</literal>. -->

				</para>

				<formalpara>
					<title>Schlüsselwort-Argumente und Dictionaries</title> <!-- Keyword Arguments and Dictionaries -->

					<para>

					Nebenbei bemerkt haben Sie bereits Dictionaries verwendet, wenn
					Sie in Ihren Funktionen Schlüsselwort-Argumente benutzt haben!
					Denken Sie einmal darüber nach - jedes Schlüssel/Wert-Paar wurde
					von Ihnen in der Parameterliste der Funktionsdefinition angegeben,
					und wenn Sie auf Variablen innerhalb der Funktion zugreifen, ist
					dies nur ein Schlüsselzugriff auf ein Dictionary (das in der Sprache
					der Compilerbauer die <emphasis>Symbol-Tabelle</emphasis> genannt wird).

					<!-- On a different note, if you have used keyword arguments in your
					functions, you have already used dictionaries! Just think about it
					- the key/value pair is specified by you in the parameter list of
					the function definition and when you access variables within your
					function, it is just a key access of a dictionary (which is called
					the <emphasis>symbol table</emphasis> in compiler design
					terminology). -->

					</para>
				</formalpara>
			</section>
		</section>
	</section>
	<section id="sequences">
		<title>Sequenzen</title> <!-- Sequences -->

		<para>

		Listen, Tupel und Strings sind Beispiele für Sequenzen, aber was sind Sequenzen
		und was ist an ihnen so besonders? Zwei Haupteigenschaften einer Sequenz sind
		der <emphasis role="bold">Indizierungsoperator</emphasis>, der es uns ermöglicht,
		direkt auf ein bestimmtes Objekt in einer Sequenz zuzugreifen, und der
		<emphasis role="bold">Teilbereichsoperator</emphasis>, der es uns erlaubt,
		eine Teilsequenz der gesamten Sequenz zu erhalten.

		<!-- Lists, tuples and strings are examples of sequences, but what are sequences and what is
		so special about them? Two of the main features of a sequence is the
		<emphasis role="bold">indexing</emphasis> operation which allows us to fetch a particular
		item in the sequence directly and the <emphasis role="bold">slicing</emphasis> operation
		which allows us to retrieve a slice of the sequence i.e. a part of the sequence. -->

		</para>

		<section id="using-sequences">
			<title>Benutzung von Sequenzen</title> <!-- Using Sequences -->

			<example id="using-sequences-example">
				<title>Benutzung von Sequenzen <!-- Using Sequences -->
					(<ulink url="code/seq.py">seq.py</ulink>)
				</title>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

einkaufsliste = ['Aepfel', 'Mangos', 'Karotten', 'Bananen']

# Indizierungs-Operation
print 'Position 0 ist', einkaufsliste[0]
print 'Position 1 ist', einkaufsliste[1]
print 'Position 2 ist', einkaufsliste[2]
print 'Position 3 ist', einkaufsliste[3]
print 'Position -1 ist', einkaufsliste[-1]
print 'Position -2 ist', einkaufsliste[-2]

# Teilbereichs-Operation auf einer Liste
print 'Position 1 bis 3 ist', einkaufsliste[1:3]
print 'Position 2 bis Ende ist', einkaufsliste[2:]
print 'Position 1 bis -1 ist', einkaufsliste[1:-1]
print 'Position Anfang bis ist', einkaufsliste[:]

# Teilbereichs-Operation auf einem String
name = 'swaroop'
print 'Zeichen 1 bis 3 ist', name[1:3]
print 'Zeichen 2 bis Ende ist', name[2:]
print 'Zeichen 1 bis -1 ist', name[1:-1]
print 'Zeichen Anfang bis Ende', name[:]
				]]>
				</programlisting>
				<!-- <![CDATA[
#!/usr/bin/python

shoplist = ['apple', 'mango', 'carrot', 'banana']

# Indexing or 'Subscription' operation
print 'Item 0 is', shoplist[0]
print 'Item 1 is', shoplist[1]
print 'Item 2 is', shoplist[2]
print 'Item 3 is', shoplist[3]
print 'Item -1 is', shoplist[-1]
print 'Item -2 is', shoplist[-2]

# Slicing on a list
print 'Item 1 to 3 is', shoplist[1:3]
print 'Item 2 to end is', shoplist[2:]
print 'Item 1 to -1 is', shoplist[1:-1]
print 'Item start to end is', shoplist[:]

# Slicing on a string
name = 'swaroop'
print 'characters 1 to 3 is', name[1:3]
print 'characters 2 to end is', name[2:]
print 'characters 1 to -1 is', name[1:-1]
print 'characters start to end is', name[:]
				]]> -->
			</example>

			<section id="using-sequences-output">
				<title>Ausgabe</title> <!-- Output -->
				<screen>
				<![CDATA[
$ python seq.py
Position 0 ist Aepfel
Position 1 ist Mangos
Position 2 ist Karotten
Position 3 ist Bananen
Position -1 ist Bananen
Position -2 ist Karotten
Position 1 bis 3 ist ['Mangos', 'Karotten']
Position 2 bis Ende ist ['Karotten', 'Bananen']
Position 1 bis -1 ist ['Mangos', 'Karotten']
Position Anfang bis ist ['Aepfel', 'Mangos', 'Karotten', 'Bananen']
Zeichen 1 bis 3 ist wa
Zeichen 2 bis Ende ist aroop
Zeichen 1 bis -1 ist waroo
Zeichen Anfang bis Ende swaroop
				]]>
				</screen>
				<!-- <![CDATA[
$ python seq.py
Item 0 is apple
Item 1 is mango
Item 2 is carrot
Item 3 is banana
Item -1 is banana
Item -2 is carrot
Item 1 to 3 is ['mango', 'carrot']
Item 2 to end is ['carrot', 'banana']
Item 1 to -1 is ['mango', 'carrot']
Item start to end is ['apple', 'mango', 'carrot', 'banana']
characters 1 to 3 is wa
characters 2 to end is aroop
characters 1 to -1 is waroo
characters start to end is swaroop
				]]> -->
			</section>

			<section id="using-sequences-how">
				<title>So funktioniert es</title> <!-- How It Works -->

				<para>

				Zuerst sehen wir, wie der Indizierungsoperator verwendet wird, um einzelne
				Elemente einer Sequenz zu ermitteln. Immer wenn man wie oben bei einer
				Sequenz eine Zahl in eckigen Klammern angibt, holt Python Ihnen das Element,
				das dieser Position in der Liste entspricht. Denken Sie daran, dass Python
				von 0 anfängt zu zählen. Daher holt <literal>einkaufsliste[0]</literal> das
				erste Element und <literal>einkaufsliste[3]</literal> das vierte Element
				der Sequenz <varname>einkaufsliste</varname>.

				<!-- First, we see how to use indexes to get individual items of a sequence.
				This is also referred to as the subscription operation. Whenever you
				specify a number to a sequence within square brackets as shown above,
				Python will fetch you the item corresponding to that position in the
				sequence. Remember that Python starts counting numbers from 0. Hence,
				<literal>shoplist[0]</literal> fetches the first item and
				<literal>shoplist[3]</literal> fetches the fourth item in the
				<varname>shoplist</varname> sequence. -->

				</para>
				<para>

				Der Index kann auch eine negative Zahl sein. In diesem Fall wird die
				Position vom Ende der Sequenz her gezählt. Daher bezieht sich
				<literal>einkaufsliste[-1]</literal> auf das letzte Element der Sequenz
				und <literal>einkaufsliste[-2]</literal> auf das vorletzte Element der Sequenz.

				<!-- The index can also be a negative number, in which case, the position is
				calculated from the end of the sequence. Therefore,
				<literal>shoplist[-1]</literal> refers to the last item in the sequence and
				<literal>shoplist[-2]</literal> fetches the second last item in the
				sequence. -->

				</para>
				<para>

				Der Teilbereichsoperator wird verwendet, indem man den Namen der Sequenz
				gefolgt von einem optionalen Zahlenpaar angibt, das durch einen Doppelpunkt
				innerhalb von eckigen Klammern getrennt wird. Beachten Sie, dass dies sehr
				ähnlich dem Indizierungsoperator ist, den Sie bisher verwendet haben.
				Denken Sie daran, dass die Zahlen optional sind, der Doppelpunkt aber nicht.

				<!-- The slicing operation is used by specifying the name of the sequence followed
				by an optional pair of numbers separated by a colon within square brackets.
				Note that this is very very similar to the indexing operation you have been
				using til lnow. Remember the numbers are optional but the colon isn't. -->

				</para>
				<para>

				Die erste Zahl (vor dem Doppelpunkt) in der Teilbereichs-Operation bezieht
				sich auf die Position, wo der Teilbereich anfängt, und die zweite Zahl
				(nach dem Doppelpunkt) gibt an, wo der Teilbereich aufhört. Wenn die erste Zahl
				nicht angegeben wird, dann fängt Python am Anfang der Sequenz an. Wenn die zweite
				Zahl weggelassen wird, dann hört Python am Ende der Sequenz auf. Beachten Sie,
				dass die zurückgegebene Teilsequenz <emphasis>an</emphasis> der Startposition
				<emphasis>anfängt</emphasis> und direkt <emphasis>vor</emphasis> der Endposition
				<emphasis>aufhört</emphasis>, d.h. die Startposition ist in der Teilsequenz
				enthalten, aber die Endposition gehört nicht mehr dazu.

				<!-- The first number (before the colon) in the slicing operation refers to the
				position from where the slice starts and the second number (after the colon)
				indicates where the slice will stop at. If the first number is not specified,
				Python will start at the beginning of the sequence. If the second number is
				left out, Python will stop at the end of the sequence. Note that the slice
				returned <emphasis>starts</emphasis> at the start position and will end
				just before the <emphasis>end</emphasis> position i.e. the start position is
				included but the end position is excluded from the sequence slice. -->

				</para>
				<para>

				Daher gibt <literal>einkaufsliste[1:3]</literal> einen Teilbereich der
				Sequenz zurück, der bei der Position 1 beginnt, die Position 2 enthält,
				aber vor der Position 3 endet, weswegen ein <emphasis>Teilbereich</emphasis>
				mit nur zwei Elementen zurückgegeben wird. Entsprechend liefert
				<literal>einkaufsliste[:]</literal> eine Kopie der gesamten Liste zurück.

				<!-- Thus, <literal>shoplist[1:3]</literal> returns a slice of the sequence
				starting at position 1, includes position 2 but stops at position 3 and
				therefore a <emphasis>slice</emphasis> of two items is returned.
				Similarly, <literal>shoplist[:]</literal> returns a copy of the whole
				sequence. -->

				</para>
				<para>

				Man kann auch beim Teilbereichsoperator negative Positionen verwenden.
				Negative Zahlen werden für Positionen vom Ende der Sequenz aus verwendet.
				Zum Beispiel gibt <literal>einkaufsliste[:-1]</literal> eine Teilsequenz
				zurück, die das letzte Element der Sequenz ausschließt, aber alle anderen
				Elemente der Sequenz enthält.


				<!-- You can also do slicing with negative positions. Negative numbers are used
				for positions from the end of the sequence. For example,
				<literal>shoplist[:-1]</literal> will return a slice of the sequence which
				excludes the last item of the sequence but contains everything else. -->

				</para>
				<para>

				Experimentieren Sie mit verschiedenen Kombinationen solcher Teilbereichsangaben,
				indem Sie den Python-Interpreter interaktiv benutzen, d.h. die Interpreter-Eingabeaufforderung,
				damit Sie die Ergebnisse direkt sehen können. Das großartige an Sequenzen ist,
				dass man auf Tupel, Listen und Strings alle auf die gleiche Weise zugreifen kann.

				<!-- Try various combinations of such slice specifications using the Python
				interpreter interactively i.e. the prompt so that you can see the results
				immediately. The great thing about sequences is that you can access
				tuples, lists and strings all in the same way! -->

				</para>
			</section>
		</section>
	</section>

	<section id="references">
		<title>Referenzen</title> <!-- References -->

		<para>

		Wenn Sie ein Objekt anlegen und es einer Variablen zuweisen, dann
		<emphasis>referenziert</emphasis> die Variable nur das Objekt, und stellt
		nicht das Objekt selber dar! Das heißt, der Variablenname zeigt nur auf
		den Teil des Speichers Ihres Computers, an dem das Objekt abgespeichert ist.
		Dies wird als <emphasis role="bold">Bindung</emphasis> des Namens an das
		Objekt bezeichnet.

		<!-- When you create an object and assign it to a variable, the variable only
		<emphasis>refers</emphasis> to the object and does not represent the object itself!
		That is, the variable name points to that part of your computer's memory where the
		object is stored. This is called as <emphasis role="bold">binding</emphasis> of the
		name to the object. -->

		</para>
		<para>

		Im Allgemeinen brauchen Sie sich darüber keine Gedanken zu machen, aber
		es gibt aufgrund der Referenzierung einen subtilen Effekt, dessen Sie sich
		bewusst sein sollten. Dies wird durch das folgende Beispiel demonstriert.

		<!-- Generally, you don't need to be worried about this, but there is a subtle effect due
		to references which you need to be aware of. This is demonstrated by the following
		example. -->

		</para>

		<section id="objects-and-references">
			<title>Objekte und Referenzen</title> <!-- Objects and References -->

			<example id="objects-and-references-example">
				<title>Objekte und Referenzen <!-- Objects and References -->
					(<ulink url="code/referenz.py">referenz.py</ulink>)
				</title>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

print 'Einfache Zuweisung'
einkaufsliste = ['Aepfel', 'Mangos', 'Karotten', 'Bananen']
meineliste = einkaufsliste
# meineliste ist nur ein anderer Name, der auf das gleiche Objekt zeigt!

# Ich habe den ersten Posten gekauft und entferne ihn daher von der Liste
del einkaufsliste[0]

print 'einkaufsliste ist', einkaufsliste
print 'meineliste ist', meineliste
# Beachten Sie, dass sowohl einkaufsliste als auch meineliste
# die gleiche Liste ohne die 'Aepfel' ausgeben, was bestaetigt,
# dass sie auf das gleiche Objekt zeigen

print 'Kopie mittels Teilbereichsoperation'
meineliste = einkaufsliste[:] # auf diese Weise wird die gesamte Liste kopiert
del meineliste[0] # entferne das erste Element

print 'einkaufsliste ist', einkaufsliste
print 'meineliste ist', meineliste
# Beachten Sie, dass die beiden Listen nun unterschiedlich sind
				]]>
				</programlisting>
				<!-- <![CDATA[
#!/usr/bin/python

print 'Simple Assignment'
shoplist = ['apple', 'mango', 'carrot', 'banana']
mylist = shoplist # mylist is just another name pointing to the same object!

del shoplist[0] # I purchased the first item, so I remove it from the list

print 'shoplist is', shoplist
print 'mylist is', mylist
# notice that both shoplist and mylist both print the same list without
# the 'apple' confirming that they point to the same object

print 'Copy by making a full slice'
mylist = shoplist[:] # make a copy by doing a full slice
del mylist[0] # remove first item

print 'shoplist is', shoplist
print 'mylist is', mylist
# notice that now the two lists are different
				]]> -->
			</example>

			<section id="objects-and-references-output">
				<title>Output</title>

				<screen>
				<![CDATA[
$ python referenz.py
Einfache Zuweisung
einkaufsliste ist ['Mangos', 'Karotten', 'Bananen']
meineliste ist ['Mangos', 'Karotten', 'Bananen']
Kopie mittels Teilbereichsoperation
einkaufsliste ist ['Mangos', 'Karotten', 'Bananen']
meineliste ist ['Karotten', 'Bananen']
				]]>
				</screen>
				<!-- <![CDATA[
$ python reference.py
Simple Assignment
shoplist is ['mango', 'carrot', 'banana']
mylist is ['mango', 'carrot', 'banana']
Copy by making a full slice
shoplist is ['mango', 'carrot', 'banana']
mylist is ['carrot', 'banana']
				]]> -->
			</section>

			<section id="objects-and-references-how">
				<title>So funktioniert es</title> <!-- How It Works -->

				<para>

				Die Erklärung findet sich größtenteils schon in den Kommentaren.
				Denken Sie daran, dass Sie den Teilbereichsoperator
				verwenden müssen, wenn Sie eine Kopie einer Liste oder derartiger
				Sequenzen oder komplexer Objekte (nicht einfacher
				<emphasis>Objekte</emphasis> wie Ganzzahlen) erstellen wollen.
				Wenn Sie nur den Variablennamen einem anderen Namen zuweisen,
				dann <emphasis>referenzieren</emphasis> beide Namen das gleiche
				Objekt, was zu allen möglichen Schwierigkeiten führen kann, wenn
				Sie dies nicht beachten.

				<!-- Most of the explanation is available in the comments itself. What you
				need to remember is that if you want to make a copy of a list or such
				kinds of sequences or complex objects (not simple <emphasis>objects</emphasis>
				such as integers), then you have to use the slicing operation to make a
				copy. If you just assign the variable name to another name, both of them
				will <emphasis>refer</emphasis> to the same object and this could lead to
				all sorts of trouble if you are not careful. -->

				</para>

				<note>
					<title>Anmerkung für Perl-Programmierer</title> <!-- Note for Perl programmers -->

					<para>

					Denken Sie daran, dass Zuweisungsanweisungen für Listen
					<emphasis role="bold">nicht</emphasis> eine Kopie erzeugen.
					Sie müssen den Teilbereichsoperator verwenden, um eine Kopie
					der Sequenz zu erzeugen.

					<!-- Remember that an assignment statement for lists does
					<emphasis role="bold">not</emphasis> create a copy. You have to use
					slicing operation to make a copy of the sequence. -->

					</para>
				</note>
			</section>
		</section>
	</section>
	<section id="more-about-strings">
		<title>Mehr über Strings</title> <!-- More about Strings -->

		<para>

		Wir haben Strings bereits früher ausführlich besprochen. Was kann es
		noch mehr geben, das man darüber wissen muss? Nun, wussten Sie, dass
		Strings auch Objekte sind und Methoden haben, die alle möglichen Dinge
		tun können, von der Überprüfung auf einen Teilstring bis hin zum
		Entfernen von Leerzeichen am Anfang oder Ende!

		<!-- We have already discussed strings in detail earlier. What more can there be to know?
		Well, did you know that strings are also objects and have methods which do everything
		from checking part of a string to stripping spaces! -->

		</para>
		<para>

		Die Strings, die Sie in Ihren Programmen benutzen, sind allesamt Objekte
		der Klasse <classname>str</classname>. Einige nützliche Methoden dieser
		Klasse werden im nächsten Beispiel demonstriert. Eine vollständige Liste
		dieser Methoden erhalten Sie mit <literal>help(str)</literal>.

		<!-- The strings that you use in program are all objects of the class <classname>str</classname>.
		Some useful methods of this class are demonstrated in the next example. For a complete list
		of such methods, see <literal>help(str)</literal>. -->

		</para>

		<section id="string-methods">
			<title>String-Methoden</title> <!-- String Methods -->

			<example id="string-methods-example">
				<title>String-Methoden <!-- String Methods -->
					(<ulink url="code/str_methoden.py">str_methoden.py</ulink>)
				</title>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

name = 'Swaroop' # Dies ist ein String-Objekt

if name.startswith('Swa'):
	print 'Ja, der String beginnt mit "Swa".'

if 'a' in name:
	print 'Ja, er enthält den String "a".'

if name.find('war') != -1:
	print 'Ja, er enthält den String "war".'

trennzeichen = '_*_'
meineliste = ['Brasilien', 'Russland', 'Indien', 'China']
print trennzeichen.join(meineliste)
				]]>
				</programlisting>
				<!-- <![CDATA[
#!/usr/bin/python

name = 'Swaroop' # This is a string object

if name.startswith('Swa'):
	print 'Yes, the string starts with "Swa"'

if 'a' in name:
	print 'Yes, it contains the string "a"'

if name.find('war') != -1:
	print 'Yes, it contains the string "war"'

delimiter = '_*_'
mylist = ['Brazil', 'Russia', 'India', 'China']
print delimiter.join(mylist)
				]]> -->
			</example>

			<section id="string-methods-output">
				<title>Ausgabe</title> <!-- Output -->
				<screen>
				<![CDATA[
$ python str_methoden.py
Ja, der String beginnt mit "Swa".
Ja, er enthält den String "a".
Ja, er enthält den String "war".
Brasilien_*_Russland_*_Indien_*_China
				]]>
				</screen>
				<!-- <![CDATA[
$ python str_methods.py
Yes, the string starts with "Swa"
Yes, it contains the string "a"
Yes, it contains the string "war"
Brazil_*_Russia_*_India_*_China
				]]> -->
			</section>

			<section id="string-methods-how">
				<title>So funktioniert es</title> <!-- How It Works -->

				<para>

				Wir sehen hier eine Anzahl von String-Methoden in Aktion.
				Die Methode <methodname>startswith</methodname> wird benutzt,
				um herauszufinden, ob der String mit einem vorgegebenen String
				beginnt. Der <literal>in</literal>-Operator wird benutzt, um
				zu überprüfen, ob ein vorgegebener String ein Teil des Strings ist.

				<!-- Here, we see a lot of the string methods in action. The
				<methodname>startswith</methodname> method is used to find out whether the
				string starts with the given string. The <literal>in</literal> operator is
				used to check if a given string is a part of the string. -->

				</para>
				<para>

				Die Methode <methodname>find</methodname> wird benutzt, um
				die Position eines vorgegebenen Strings im String zu finden.
				Sie liefert eine -1 zurück, wenn sie den Teilstring nicht
				erfolgreich finden konnte. Die Klasse <classname>str</classname>
				hat auch eine praktische Methode namens <methodname>join</methodname>,
				mit der man die Elemente einer Sequenz zusammenfügen kann,
				wobei der String als eine Kette von Trennzeichen fungiert,
				die zwischen jedes Element der Sequenz eingefügt wird, um so
				einen größeren daraus zusammengebauten String zu erzeugen.

				<!-- The <methodname>find</methodname> method is used to do find the position of
				the given string in the string or returns -1 if it is not successful to find
				the substring. The <classname>str</classname> class also has a neat method
				to <methodname>join</methodname> the items of a sequence with the string
				acting as a delimiter between each item of the sequence and returns a bigger
				string generated from this. -->

				</para>
			</section>
		</section>
	</section>

	<section id="data-structures-summary">
		<title>Zusammenfassung</title> <!-- Summary -->

		<para>

		Wir haben die verschiedenen eingebauten Datenstrukturen von Python
		ausführlich untersucht. Diese Datenstrukturen sind unabdingbar, wenn
		man Programme mit einer vernünftigen Größe schreiben möchte.

		<!-- We have explored the various built-in data structures of Python in detail. These
		data structures will be essential for writing programs of reasonable size. -->

		</para>
		<para>

		Nachdem wir uns nun mit den Grundlagen von Python vertraut gemacht haben,
		werden wir als Nächstes sehen, wie wir ein richtiges Python-Programm
		entwerfen und schreiben können.

		<!-- Now that we have a lot of the basics of Python in place, we will next see how to
		design and write a real-world Python program. -->

		</para>
	</section>
</chapter>
